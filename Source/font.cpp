//==============================================================================
// タイトル     :   文字列関係処理の抽象クラス
// ファイル名   :   font.cpp
// 作成者       :   AT13B284 21 数藤凌哉
// 作成日       :   2016/05/18
//==============================================================================

//==============================================================================
// 更新履歴: -2016/05/18 数藤凌哉
//           ・制作開始
//==============================================================================

//==============================================================================
// WARNIG防止
//==============================================================================
#define _CRT_SECURE_NO_WARNINGS

//==============================================================================
// インクルードファイル
//==============================================================================
#include "font.h"
#include <stdio.h>
#include <string.h>
#include <stdarg.h>

//==============================================================================
// 列挙型宣言
//==============================================================================

//==============================================================================
// マクロ定義
//==============================================================================

//==============================================================================
// 構造体宣言
//==============================================================================

//==============================================================================
// プロトタイプ宣言
//==============================================================================

//==============================================================================
// グローバル宣言
//==============================================================================

//==============================================================================
// 静的変数
//==============================================================================

//==============================================================================
// 関数名 : CFont()
// 引数   : void
// 戻り値 : void
// 説明   : デフォルトコンストラクタ
//==============================================================================
CFont::CFont()
{
	m_refHIdx = 0;
}

//==============================================================================
// 関数名 : ~CFont()
// 引数   : void
// 戻り値 : void
// 説明   : デストラクタ
//==============================================================================
CFont::~CFont()
{
}

//==============================================================================
// 関数名 : bool Init( void )
// 引数   : void
// 戻り値 : bool型
// 説明   : 初期化処理
//==============================================================================
bool CFont::Init( void )
{
	CFont::ResetBuff();					// 出力バッファーの初期化
	return true;
}

//==============================================================================
// 関数名 : void Uninit( void )
// 引数   : void
// 戻り値 : void
// 説明   : 終了処理
//==============================================================================
void CFont::Uninit( void )
{

}

//==============================================================================
// 関数名 : bool Cat( char* source )
// 引数   : char* source : 連結元
// 戻り値 : bool型       : 処理結果
// 説明   : 出力バッファーの文字列との連結処理
//==============================================================================
bool CFont::Cat( char* source )
{
	// ----------------------------------------------------------------------
	// [ 取得した文字列とバッファーの文字列を連結 ]
	// ----------------------------------------------------------------------
	char* strTop = source;											// 参照地点の先頭
	char* strCur = source;											// 現在の参照地点
	bool bResult = false;											// 処理結果
	int len = 0;													// 参照文字長

	if( source == NULL )
	{
		return false;												// エラーチェック
	}

	while( *strTop != '\0' )
	{
		/* ===改行コードのまでの文字長を確認=== */
		len = 0;

		while( *strCur != '\n' && *strCur != '\0' )
		{
			len++;
			strCur++;
		}

		/* ===文字列の結合=== */
		int destLen   = 0;														// 出力先の文字長
		int sourceLen = 0;														// 出力元の文字長
		int limitSize = ( OUT_BUFF_SIZE_WIDTH * OUT_BUFF_SIZE_HEIGHT ) - ( m_refHIdx * OUT_BUFF_SIZE_WIDTH );	// 限界許容サイズ

		destLen = strlen( &m_outBuffHW[ m_refHIdx ][ 0 ] );						// 現在格納されている文字長を取得
		sourceLen = strlen( strCur );											// 出力元の文字長を取得

		if( destLen + sourceLen <= limitSize )									// バッファオーバーさせないようにリミッターをかける
		{
			strncat( &m_outBuffHW[ m_refHIdx ][ 0 ] , strTop , len );			// 取得した情報の結合
		}
		else
		{
			return false;														// 処理失敗
		}

		// 改行の処理
		while( len >= OUT_BUFF_SIZE_WIDTH )
		{
			len -= OUT_BUFF_SIZE_WIDTH;
			m_refHIdx++;
		}

		while( *strCur == '\n' )
		{
			strCur++;
			m_refHIdx++;
		}

		if( m_refHIdx >= OUT_BUFF_SIZE_HEIGHT )
		{
			m_refHIdx = OUT_BUFF_SIZE_HEIGHT - 1;
		}

		// 参照位置変更
		strTop = strCur + len;													// 先頭位置をずらす
	}

	if( *strTop == '\0' )
	{
		bResult = true;															// 処理成功
	}

	//strCur = strtok( source , "\n" );

	//while( strCur != NULL )
	//{
	//	int nDestLen = 0;											// 出力先の文字長
	//	int nSourceLen = 0;											// 出力元の文字長

	//	strNext = strtok( NULL , "\n" );

	//	nDestLen = strlen( &m_outBuffW[ 0 ] );						// 現在格納されている文字長を取得
	//	nSourceLen = strlen( strCur );								// 出力元の文字長を取得

	//	if( nDestLen + nSourceLen <= FONT_LIMIT_OUT_BUFF_SIZE )		// バッファオーバーさせないようにリミッターをかける
	//	{
	//		strcat( &m_outBuffHW[ m_refHIdx ][ 0 ] , strCur );		// 取得した情報の結合
	//		bResult = true;											// 処理成功
	//	}

	//	if( strNext != NULL )
	//	{
	//		if( m_refHIdx < OUT_BUFF_SIZE_HEIGHT - 1 )
	//		{
	//			/* ===改行コードの個数を確かめる=== */
	//			char* checkStr = strCur;
	//			int newLineCnt = 0;

	//			while( checkStr != strNext )
	//			{
	//				if( *checkStr == '\n' )
	//				{
	//					newLineCnt++;		// 改行コード発見
	//				}

	//				checkStr++;				// 次のトークンに移動
	//			};

	//			m_refHIdx += newLineCnt;	// 見つけた分だけ改行

	//			if( m_refHIdx >= OUT_BUFF_SIZE_HEIGHT )
	//			{
	//				m_refHIdx = OUT_BUFF_SIZE_HEIGHT - 1;		// 最大参照位置まで戻す
	//			}
	//		}
	//	}

	//	strCur = strNext;

	//}

	return bResult;												// 処理結果の返却
}

//==============================================================================
// 関数名 : bool Print( char *fmt , ... )
// 引数   : char *fmt : 格納する文字列
//          ...       : 可変引数( 文字列に変換し格納 )
// 戻り値 : bool型    : 処理結果
// 説明   : 出力バッファーに文字列を送る処理
//==============================================================================
bool CFont::Print( char *fmt , ... )
{
	// ----------------------------------------------------------------------
	// [ 取得した文字列をバッファーに格納 ]
	// ----------------------------------------------------------------------
	va_list ap;															// 可変引数用のポインタ
	char aSourceBuff[ OUT_BUFF_SIZE_HEIGHT * OUT_BUFF_SIZE_WIDTH ];		// 取得情報のバッファー
	bool bResult =  false;												// 処理結果

	va_start( ap, fmt );												// 可変引数を用いる設定

	vsprintf( &aSourceBuff[ 0 ] , fmt , ap );							// 取得した情報を格納

	va_end( ap );														// 可変引数設定終了

	// ----------------------------------------------------------------------
	// [ 出力バッファーに生成した文字列を格納 ]
	// ----------------------------------------------------------------------
	bResult = this->Cat( aSourceBuff );									// 文字結合

	return bResult;														// 処理結果の返却
}

//==============================================================================
// 関数名 : void ResetBuff( void )
// 引数   : void
// 戻り値 : void
// 説明   : 出力バッファーの初期化処理
//==============================================================================
void CFont::ResetBuff( void )
{
	memset( m_outBuffW , 0 , sizeof( m_outBuffW ) );	// 中身0埋め

	m_refHIdx = 0;										// 参照インデックスリセット
}
