//------------------------------------------------------------
// [ OBJ形式のデータ読み込み ]
//------------------------------------------------------------
1 : トークン解析を行う。

『 # 』: コメント
『 g 』: グループ名
『 m 』: マテリアルへのファイルパス
『 u 』: 面に使用するマテリアルの名前
『 f 』: 面データ
『 v 』: ２文字目の解析を行うことで判別。
	└『   』 : 頂点データ
	└『 t 』 : テクスチャ座標
	└『 n 』 : 法線データ

2 : 要素数の算出
・バッファーを動的確保するために、whileループで要素数を確認。
	└違うトークンが出てくるまでの個数だけ確保。
	
3 : データ格納
・v〜系データに関して
	└・それぞれのデータ形式に合わせたサイズを動的確保
	└・終了地点までforループ
fscanf( fp , "%f〜" )

・fデータに関して
	└・インデックス用バッファーを動的確保
	└・決まった形式の判別ができないため、1文字ずつ解析
		└・解決可能？

//------------------------------------------------------------
// [ 仕様 ]
//------------------------------------------------------------
class CMaterial{
	CMaterial();
	~CMaterial();
	
	char m_name[ 64 ];			// 名前
	
	COLOR_FLOAT m_diffuse;
	COLOR_FLOAT m_ambient;
	COLOR_FLOAT m_specular;
	
	char m_texPath[ MAX_PATH ];
};

class CModel{
	
	struct PARTS{
		char m_name[ 64 ];		// グループ名
		
		VECTOR3* m_pVtx;		// 頂点データ
		VECTOR3* m_pTex;		// テクスチャデータ
		VECTOR3* m_pNor;		// 法線データ
		
		int* m_pVtxIdx;			// 頂点インデックス
		int* m_pTexIdx;			// テクスチャインデックス
		int* m_pNorIdx;			// 法線インデックス
		
		int m_primNum;			// プリミティブ数
		
		CMaterial* pMat;		// マテリアルへのポインタ
	};
	
	PARTS* pParts;
	int m_numParts;
	

};



